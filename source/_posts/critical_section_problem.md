---
title: 临界区
categories:
- 聊天室
- 多线程
tags: [聊天室,pthread]
date: 2022-05-12 20:46:00
---
通常多线程修改全局数据时会使用临界区。

当多段进程访问同一代码段时，该代码段称为临界区。临界区包含共享变量和资源，需要同步以保持数据变量的一致性。
<!--more-->
### 临界区
简单来说，临界区是需要以原子方式执行的一组指令/语句或代码区域，任何时候只能有一个线程执行临界区代码，例如访问文件、输入输出端口、全局变量。

### 临界区资源的互斥访问
实现线程对临界资源的互斥访问就是让各个线程互斥的进入自己的临界区，也就是说当某个线程在临界区内执行时，其他线程都不能访问自己的临界区，这样就保证了在某个时间内只有一个线程在临界区内使用临界资源，也就实现了临界资源的互斥访问。

### 临界区的分块
整个线程访问临界区分为以下三个部分：

- **进入区（entry section）**：在进入临界区之前，检查是否可进入临界区的一段代码。如果可以进入临界区，通常设置相应的“允许访问临界区”标志。
- **退出区（exit section）**： 用于将“允许访问临界区”标志清除。
- **剩余区** ：代码中的剩余部分。

### 如何实现进程间的互斥？
这里列举一个现实中滑梯的例子，滑梯一次只能进一个小朋友，当有很多小朋友都想玩的时候，其中一个解决方案是让小朋友们`轮流`玩，另一个方案是让小朋友们提出滑滑梯`申请`。在解决进程间互斥的时候，也是借助了这两个思想，这里介绍两种算法。

#### 算法1
设立一个两进程公用的整形变量`turn`，用于描述允许进入临界区的进程标识，进程标识有两个进程`Pi`和`Pj`，如果`turn == i` ，那么`Pi`允许在其临界区执行。即采用轮流的方式，用`turn`表示当前运行哪个进程进入临界区。
`Pi`进入临界区的伪代码如下

	while (turn != i); 	// 判断是否轮到 Pi 
		critical section; 	// 执行临界区
	turn = j; 	// 执行完临界区就轮到下一个 Pj
		remainder section; 	// 执行剩余区

对于之前提到的临界区互斥问题的三个要求，本算法显然满足临界区解决方案的`互斥`要求。实际上，此算法是强制轮流进入临界区，没有考虑进程的实际需要，若`Pi`执行完临界区，`turn`也转交给了`Pj`，但是此时`Pj`不需要使用临界区，那么临界区就处于空闲状态。而此时`turn`不属于`Pi`,所以`Pi`依然无法进入临界区，容易造成资源利用的不充分，所以不满足临界区解决方案的第二个要求`有空让进`和第三个要求`有限等待`。

#### 算法2
由于算法1只记住了哪个进程能进入临界区，没有保存进程的状态，所以设立一个标志数组`flag[]`，用来描述进程是否准备进入临界区，初值均为`FALSE`，通过先申请后检查的机制防止两个进程同时进入临界区。
`Pi`进入临界区的伪代码如下：

	flag[i] = TURE; // Pi 申请执行临界区
	while (flag[j]); // 判断 Pj 是不是在执行临界区或它也想执行临界区
	    critical section;
	flag[i] = FALSE; // Pi 执行完临界区，撤销之前的申请
	    remainder section;

该算法显然满足`互斥`要求，因为每次执行临界区前都会判断对方是否在执行临界区或者是否也想进入临界区，但是若某个时刻`Pi`和`Pj`都申请执行临界区，就会导致谁都没法执行临界区，所以不满足`有空让进`的要求，算法2对比算法1的优点是不用交替进入，可以连续使用，不用等待对方，缺点是两进程可能都进入不了临界区。

#### 算法3
在算法2的基础是进一步改进，同样是要先申请执行临界区，但要先把`turn`改为对方，然后再进行检查。若当前对方在执行临界区或者对方想要执行临界区且`turn`也是对方，那么就等待对方先执行完。
`Pi`进入临界区的伪代码如下：

	flag[i] = TURE; // Pi 申请执行临界区
	turn = j; // 让 Pj 下次执行
	while (flag[j] && turn = j); // 判断 Pj 是不是在执行临界区或它也想执行临界区且当且turn为它
	    critical section;
flag[i] = FALSE; // Pi 执行完临界区，撤销之前的申请
    remainder section;

算法3解决了算法1和算法2的缺点，同时算法3具有先到先入，后到等待的优点。

>引用
https://blog.csdn.net/syzdev/article/details/104898592
https://www.geeksforgeeks.org/g-fact-70/
https://blog.csdn.net/syzdev/article/details/104898592