---
title: 进程同步
categories:
- 聊天室
- 多线程
tags: [聊天室,pthread]
date: 2022-05-12 21:25:00
---

在同步的基础上，进程被分为以下两种：

- 独立进程：一个进程的执行不影响其他进程的执行。
- 协作进程：一个进程的执行会对其他进程的执行造成影响。

在协作进程的情况下会出现进程同步问题，因为资源在协作进程中共享。
<!--more-->
### 竞争条件
当多个进程正在执行相同代码、访问相同内存或者任何共享变量时，公共变量的输出或者值可能就可能发生错误。

竞争条件通常发生在临界区，若临界区中多线程执行的结果跟据线程执行顺序的不同而发生变化，那么这些进程间就会发生竞争。

### 临界区问题
临界区是一次只能由一个进程访问的代码段，临界区的共享变量需要包含同步以保持其一致性。
![临界区](/img/process_synchronization.png)
在进入代码段时，进程会发出请求进入临界区的消息。
想要避免竞争，线程进入临界区的调度法则如下

- **互斥（Mutual Exclusion）**：如果临界区中已经有一个线程正在执行，则不再允许其他线程进入。
- **有空让进（Progress）**：临界区虽然没有进程执行，但是有些程序需要进入临界区，不能无限期的延长下一个要进入临界区的线程的等待时间。
- **有限等待（Bounded Waiting）**：在一个线程提出进入临界区的请求和该请求得到答复的时间内，其他线程进入临界区的次数必须是有限的。

### 彼得森的临界区解决方案

彼得森的解决方案是一个经典的基于软件的解决临界区问题的方法。

在彼得森的解决方案中，我们有两个公共变量：

- `bool flag[i]`：初始化为`FALSE`，最初没有人有兴趣进入临界区。
- `int turn`： 轮到进入临界区的线程。
![彼得森的临界区问题解决方案](/img/peter_solution.png)
彼得森的解决方案满足解决临界区问题的三个条件：

- 任何时候都只有一个线程可以访问临界区，保证了互斥。
- 临界区之外的线程不会阻止其他线程进入临界区，保证了有空让进。
- 每个线程进入临界区的机会均等，有限等待被保留。

彼得森解决方案的缺点

- 涉及忙等待
- 仅限于两个线程

### 信号量（Semaphores）
临界区是平等进程之间的一种协商机制，之前提到的轮流（`turn`）和申请(`flag[]`)都是基于两个进行的临界区模型提出的。当进程数量过多时，就要引入新的机制来解决互斥问题，操作系统可以从进程管理者的角度来处理互斥的问题，信号量就是操作系统提供的管理公有资源的有效手段。

一个信号量`S`是一个整型变量，它除了初始化外只能通过两个不可分割的原子操作访问，即`P(S)`和`V(S)`，简称为P、V操作。

- 操作wait()称为P，表示申请一个资源，可按照如下方式定义
```
P(S); // 申请资源
    while (S <= 0); // 当前没有可用资源就要一直等待
S--; // 若有资源，就要总资源数减一
V(S); // 使用完资源要释放资源
S++; // 释放资源
```
由于`S`表示当前可用资源的数量，当`S<=0`时，会一直等待资源，存在`忙等现象`，又称为`自旋锁`，此时CPU利用效率不高。

为了解决忙等现象，引入了一种不需要忙等的方案，将`S--`操作提前，先减再判断`S`的值，若判断的`S<0`，就让进程进入阻塞状态（通常是设置一个阻塞进程队列），在释放资源时，若`S>=0`,则要唤醒被阻塞的进程，伪代码如下：
```
P(S); // 申请资源
    S--; // 总资源数减一
    if (S < 0) {
        block; // 若当前无可用资源，则将该进程阻塞
    }
V(S); // 使用完资源要释放资源
    S++; // 释放资源
    if (S >= 0) {
        wakeup; // 若当前有可用资源，则将之前阻塞的进程唤醒
    }

```

- 操作signal()称为V，表示释放一个资源
```
    signal(S) {
        S++;
    }
```

一般来说，初始化指定一个非负整数值，表示空闲资源总数，在信号量经典定义下，信号量`S`的值不可能为负，后面的定义下可能为负，因为后面的定义中先做了`S--`。

- `S>=0` 表示可供并发进程使用的资源数
- `S<0` 其绝对值就是正在等待进入临界区的进程数。
用信号量解决问题时，首要任务是分清这个问题是同步问题还是互斥问题，若是互斥问题，就要找到互斥的临界资源，并把临界资源抽象为信号量，然后给信号量赋初值并给出正确的P，V操作。

在P，V操作中，信号量整数值的修改应该原子的执行，也就是说当一个进程修改信号量的值时，没有其他进程能够同时修改同一信号量的值。
>引用
http://c.biancheng.net/view/1232.html
https://blog.csdn.net/syzdev/article/details/104898592